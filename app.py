from flask import Flask, request, jsonify, render_template, abort, current_app
from config import (
    UPLOAD_FOLDER, JSON_RESULTS_FOLDER,
    CELERY_BROKER_URL, CELERY_RESULT_BACKEND, CELERY_INCLUDE,
    MIN_MATCH_LEN
)
from upload import process_and_save_file
from compare import perform_comparison, get_content_info, retrieve_content_from_db
from helpers import _strip_cleaned_suffix, highlight_char_spans, read_text, highlight_texts, highlight_with_difflib, get_difflib_spans
from db_utils import get_db_connection
from celery_app import make_celery
from flask_cors import CORS
import os
import time
import datetime
from datetime import timezone
import subprocess
import threading
import webbrowser
import uuid
import re
import json
import logging

from async_tasks_utils import generate_and_save_comparison_json 

app = Flask(__name__, template_folder='templates')
CORS(app, origins=["http://localhost:5173", "https://test1.bitirme-intihal.xyz"]) 

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['JSON_RESULTS_FOLDER'] = JSON_RESULTS_FOLDER
app.config['MIN_MATCH_LEN'] = MIN_MATCH_LEN

app.config['CELERY_BROKER_URL'] = CELERY_BROKER_URL
app.config['CELERY_RESULT_BACKEND'] = CELERY_RESULT_BACKEND
app.config['CELERY_INCLUDE'] = CELERY_INCLUDE

app.config['CODE_LANGS'] = {
    "java","c","cpp","csharp","python3","javascript","typescript",
    "golang","kotlin","rlang","rust","swift","scala","llvmir","scheme",
    "emf","emf-model","scxml", "python"
}

celery = make_celery(app)

VIEW_PROCS: dict[str, subprocess.Popen] = {}

@celery.task(name='app.tasks.create_all_detailed_comparison_jsons')
def create_all_detailed_comparison_jsons_task(content_id):
    with app.app_context(): 
        current_app.logger.info(f"Async task 'create_all_detailed_comparison_jsons_task' started for content_id: {content_id}")
        
        try:
            icerik_turu, _ = get_content_info(content_id) 
            if icerik_turu and icerik_turu.lower() in current_app.config['CODE_LANGS']:
                current_app.logger.info(f"Skipping detailed JSON generation for JPlag content_id {content_id} (IcerikTuru: {icerik_turu}).")
                return {"status": "skipped_jplag", "message": "JPlag content, detailed text JSONs not generated by this task."}
        except ValueError: 
             current_app.logger.error(f"Content ID {content_id} not found for async task.")
             return {"status": "error", "message": "Content ID not found."}

        files_info = retrieve_content_from_db(content_id) 
        
        if not files_info or len(files_info) < 2:
            current_app.logger.info(f"Not enough files for content_id {content_id} to compare asynchronously. Found {len(files_info)} files.")
            return {"status": "skipped_no_files", "message": "Not enough files or no files found for detailed comparison."}

        json_results_folder = current_app.config['JSON_RESULTS_FOLDER']
        generated_json_paths = []

        for i in range(len(files_info)):
            for j in range(i + 1, len(files_info)):
                file1_info = files_info[i]
                file2_info = files_info[j]
                
                json_path = generate_and_save_comparison_json(
                    app.app_context(), 
                    content_id, 
                    file1_info, 
                    file2_info, 
                    json_results_folder
                )
                if json_path:
                    generated_json_paths.append(json_path)
        
        if generated_json_paths:
            current_app.logger.info(f"Successfully processed and saved {len(generated_json_paths)} detailed comparisons for content_id {content_id}")
            return {"status": "success", "content_id": content_id, "message": f"{len(generated_json_paths)} detailed comparisons generated."}
        else:
            current_app.logger.info(f"No detailed comparisons were generated for content_id {content_id}.")
            return {"status": "no_new_jsons", "content_id": content_id, "message": "No new detailed comparisons were generated."}

@app.route('/upload', methods=['POST'])
def upload_file_route():
    try:
        user_id_str = request.form.get('user_id')
        content_id_str = request.form.get('content_id')
        baslik = request.form.get('baslik')
        ad_soyad = request.form.get('ad_soyad')
        icerik_turu = request.form.get('icerik_turu') 
        uploaded_file = request.files.get('file')

        if not all([user_id_str, content_id_str, baslik, ad_soyad, icerik_turu, uploaded_file]):
            return jsonify({"error": "Tüm alanlar gereklidir: user_id, content_id, baslik, ad_soyad, icerik_turu, file."}), 400

        try:
            user_id = int(user_id_str)
            content_id = int(content_id_str)
        except ValueError:
            return jsonify({"error": "user_id ve content_id sayısal değerler olmalı."}), 400

        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("SELECT KullaniciId FROM Kullanicilar WHERE KullaniciId = ?", (user_id,))
        if not cursor.fetchone():
            ad, soyad = ad_soyad.split(" ", 1) if " " in ad_soyad else (ad_soyad, "")
            cursor.execute("INSERT INTO Kullanicilar (KullaniciId, Ad, Soyad, Eposta, Rol) VALUES (?, ?, ?, ?, ?)",
                           (user_id, ad, soyad, f"{user_id}@example.com", "Ogrenci")) 

        cursor.execute("SELECT IcerikId FROM Icerikler WHERE IcerikId = ?", (content_id,))
        if not cursor.fetchone():
            cursor.execute("INSERT INTO Icerikler (IcerikId, Baslik, IcerikTuru, KullaniciId, OlusturmaTarihi) VALUES (?, ?, ?, ?, GETDATE())",
                           (content_id, baslik, icerik_turu, user_id))
        else:
            cursor.execute("UPDATE Icerikler SET IcerikTuru = ?, Baslik = ? WHERE IcerikId = ?", (icerik_turu, baslik, content_id))

        conn.commit()
        conn.close()

        safe_baslik = re.sub(r'[^\w\s-]', '', baslik).strip()
        user_folder = os.path.join(app.config['UPLOAD_FOLDER'], safe_baslik, ad_soyad)
        os.makedirs(user_folder, exist_ok=True)

        original_path = os.path.join(user_folder, uploaded_file.filename)
        uploaded_file.save(original_path)
 
        cleaned_path = process_and_save_file(original_path, user_id, content_id, icerik_turu) 

        return jsonify({
            "message": "Dosya yüklendi ve işlendi.",
            "original_path": original_path,
            "cleaned_path": cleaned_path
        }), 200

    except Exception as e:
        current_app.logger.error(f"Error in /upload: {str(e)}", exc_info=True)
        return jsonify({"error": f"Sunucu hatası: {str(e)}"}), 500

@app.route('/compare', methods=['POST'])
def compare_files_route():
    try:
        if not request.is_json:
            return jsonify({"error": "İstek JSON olmalı."}), 415

        content_id_str = request.json.get('content_id')
        if not content_id_str:
            return jsonify({"error": "İçerik ID eksik."}), 400
        
        try:
            content_id = int(content_id_str)
        except ValueError:
            return jsonify({"error": "İçerik ID sayısal bir değer olmalı."}), 400

        current_app.logger.info(f"Received /compare request for content_id: {content_id}")
        
        try:
            icerik_turu, _ = get_content_info(content_id) 
        except ValueError as e: 
            current_app.logger.error(f"Content ID {content_id} not found for comparison.")
            return jsonify({"error": str(e)}), 404

        result = perform_comparison(content_id)
        current_app.logger.info(f"perform_comparison for {content_id} (IcerikTuru: {icerik_turu}) result type: {type(result)}")

        task_status_message = ""
        if icerik_turu and icerik_turu.lower() not in app.config['CODE_LANGS']:
            try:
                task = create_all_detailed_comparison_jsons_task.delay(content_id)
                task_status_message = f"Detaylı metin karşılaştırma JSON oluşturma görevi başlatıldı (Task ID: {task.id})."
                current_app.logger.info(f"Dispatched async task for non-code content_id: {content_id}")
            except Exception as task_e:
                current_app.logger.error(f"Failed to dispatch async task for content_id {content_id}: {str(task_e)}", exc_info=True)
                task_status_message = "Detaylı metin karşılaştırma JSON oluşturma görevi tetiklenemedi."
        else:
            task_status_message = "Kod içeriği için JPlag sonuçları kullanılır, ek detaylı metin JSON görevi tetiklenmedi."
            current_app.logger.info(f"Skipped dispatching async task for JPlag content_id: {content_id} (IcerikTuru: {icerik_turu})")

        if isinstance(result, float): 
            return jsonify({
                "message": f"Metin karşılaştırması tamamlandı. {task_status_message}",
                "average_similarity": round(result, 4)
            }), 200
        elif isinstance(result, dict) and "job_id" in result: 
            return jsonify({
                "message": result.get("message", "Kod karşılaştırması JPlag ile tamamlandı.") + f" {task_status_message}",
                "port": result.get("port"),
                "job_id": result.get("job_id"),
                "web_url": f"http://localhost:{result['port']}" if result.get("port") else None
            }), 200
        else:
            current_app.logger.error(f"Unknown result type from perform_comparison for {content_id}: {result}")
            return jsonify({"error": f"Bilinmeyen karşılaştırma sonuç türü. {task_status_message}"}), 500

    except Exception as e:
        error_content_id = request.json.get('content_id', 'N/A') if request.is_json else 'N/A'
        current_app.logger.error(f"Error in /compare for content_id {error_content_id}: {str(e)}", exc_info=True)
        return jsonify({"error": f"Sunucu hatası: {str(e)}"}), 500

@app.route('/compare_async_json', methods=['POST'])
def compare_async_json_trigger_route():
    if not request.is_json:
        return jsonify({"error": "İstek JSON olmalı."}), 415
    
    content_id_str = request.json.get('content_id')
    if not content_id_str:
        return jsonify({"error": "İçerik ID eksik."}), 400
    
    try:
        content_id = int(content_id_str)
    except ValueError:
        return jsonify({"error": "İçerik ID sayısal bir değer olmalı."}), 400

    current_app.logger.info(f"Received /compare_async_json request for content_id: {content_id}")
    
    try:
        task = create_all_detailed_comparison_jsons_task.delay(content_id)
        current_app.logger.info(f"Manually triggered async task for content_id: {content_id} - Task ID: {task.id}")
        
        return jsonify({
            "message": f"Tüm dosyalar için detaylı karşılaştırma JSON oluşturma görevi başlatıldı (Content ID: {content_id}).",
            "task_id": task.id
        }), 202 
    except Exception as e:
        current_app.logger.error(f"Error triggering async task in /compare_async_json for content_id {content_id}: {str(e)}", exc_info=True)
        return jsonify({"error": f"Görev başlatılırken hata: {str(e)}"}), 500

# --- JSON DETAY ENDPOINTİ (POST ile JSON Body) ---
@app.route('/get_comparison_detail_json', methods=['POST']) # METOD POST OLARAK DEĞİŞTİRİLDİ
def get_comparison_detail_json_route():
    if not request.is_json: # İSTEĞİN JSON OLUP OLMADIĞINI KONTROL ET
        return jsonify({"error": "İstek gövdesi JSON formatında olmalı."}), 415

    data = request.get_json() # İSTEK GÖVDESİNDEN JSON VERİSİNİ AL
    content_id_str = data.get('content_id')
    file1_id_str = data.get('file1_id')
    file2_id_str = data.get('file2_id')

    if not content_id_str or not file1_id_str or not file2_id_str: # Parametrelerin varlığını kontrol et
        return jsonify({"error": "content_id, file1_id ve file2_id parametreleri JSON gövdesinde gereklidir."}), 400

    try:
        content_id = int(content_id_str)
        file1_id = int(file1_id_str)
        file2_id = int(file2_id_str)
    except ValueError:
        return jsonify({"error": "ID parametreleri sayısal değer olmalıdır."}), 400
    except TypeError: # Eğer ID'ler None ise int'e çevirme hatası almamak için
        return jsonify({"error": "ID parametreleri geçerli bir değer olmalıdır."}), 400


    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT TOP 1 JsonFilePath 
            FROM ComparisonJsonDetails
            WHERE ContentId = ? AND 
                  ((FirstFileId = ? AND SecondFileId = ?) OR (FirstFileId = ? AND SecondFileId = ?))
            ORDER BY CreatedAt DESC
        """, (content_id, file1_id, file2_id, file2_id, file1_id))
        row = cursor.fetchone()

        if row and row[0]:
            json_file_path = row[0]
            if os.path.isfile(json_file_path):
                try:
                    with open(json_file_path, 'r', encoding='utf-8') as f:
                        json_data = json.load(f)
                    return jsonify(json_data), 200
                except Exception as e:
                    current_app.logger.error(f"Error reading JSON file {json_file_path}: {e}", exc_info=True)
                    return jsonify({"error": "Detay JSON dosyası okunurken hata oluştu."}), 500
            else:
                current_app.logger.warning(f"JSON file path found in DB but file not found on disk: {json_file_path} for content {content_id}, files {file1_id}-{file2_id}")
                return jsonify({"error": "Karşılaştırma detayı dosyası bulunamadı (disk üzerinde değil)."}), 404
        else:
            current_app.logger.info(f"No comparison detail JSON found in DB for content {content_id}, files {file1_id}-{file2_id}")
            return jsonify({"error": "Belirtilen ID'ler için karşılaştırma detayı bulunamadı."}), 404

    except Exception as e:
        current_app.logger.error(f"Error fetching comparison detail JSON for content {content_id}, files {file1_id}-{file2_id}: {e}", exc_info=True)
        return jsonify({"error": "Sunucu hatası oluştu."}), 500
    finally:
        if conn:
            conn.close()
# --- JSON DETAY ENDPOINTİ SONU ---

@app.route('/compare_html', methods=['POST'])
def compare_html_route():
    data = request.get_json(force=True) 
    required = ('KullaniciAdi1', 'KullaniciAdi2', 'Dosya1', 'Dosya2', 'BenzerlikOrani')
    if not all(key in data for key in required):
        missing_keys = [key for key in required if key not in data]
        abort(400, f"Eksik anahtarlar: {', '.join(missing_keys)}")

    u1, u2 = data['KullaniciAdi1'], data['KullaniciAdi2']
    p1_orig, p2_orig = data['Dosya1'], data['Dosya2'] 
    sim_str = data['BenzerlikOrani']
    try:
        sim = float(sim_str)
    except ValueError:
        abort(400, "BenzerlikOrani sayısal bir değer olmalı.")

    if not os.path.isfile(p1_orig) or not os.path.isfile(p2_orig):
        missing = p1_orig if not os.path.isfile(p1_orig) else p2_orig
        current_app.logger.error(f"Dosya bulunamadı /compare_html: {missing}")
        abort(404, f"Dosya bulunamadı: {missing}. Lütfen dosya yollarını kontrol edin.")

    raw1 = read_text(p1_orig)
    raw2 = read_text(p2_orig)
    
    min_len_for_highlight = current_app.config.get('MIN_MATCH_LEN', 30)
    h1, h2 = highlight_with_difflib(raw1, raw2, min_len=min_len_for_highlight) 

    h1 = h1.replace('\n', '<br>')
    h2 = h2.replace('\n', '<br>')

    return render_template(
        'compare.html',
        user1=u1,
        user2=u2,
        similarity=sim,
        text1=h1,
        text2=h2
    )

@app.route('/jplag/view', methods=['POST'])
def jplag_view_route():
    if not request.is_json:
        return jsonify({"error": "JSON bekleniyor."}), 415
    
    data = request.get_json()
    cid_str = data.get("content_id")
    if not cid_str:
        return jsonify({"error": "content_id eksik."}), 400

    try:
        cid = int(cid_str)
    except ValueError:
        return jsonify({"error": "content_id sayısal bir değer olmalı."}), 400

    try:
        lang, _ = get_content_info(cid)
    except ValueError as e:
        current_app.logger.error(f"get_content_info({cid}) başarısız: {e}")
        return jsonify({"error": str(e)}), 404

    if lang.lower() not in app.config['CODE_LANGS']:
        return jsonify({"error": f"İçerik türü ({lang}) JPlag tarafından desteklenmiyor."}), 400

    # Daha önce aynı content_id ile bir arayüz zaten başlatılmış mı?
    prev = VIEW_PROCS.get(str(cid))
    if prev and prev.poll() is None:
        port_from_proc = 2999
        current_app.logger.info(f"JPlag view for {cid} already running on port {port_from_proc}.")
        return jsonify({
            "message": f"JPlag arayüzü zaten {port_from_proc} portunda çalışıyor.",
            "url": f"http://localhost:{port_from_proc}"
        }), 200

    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(
            "SELECT TOP 1 ZipPath FROM JplagJobs WHERE IcerikId = ? ORDER BY CreatedAt DESC",
            (cid,)
        )
        row = cur.fetchone()
    except Exception as db_err:
        current_app.logger.error(f"Veritabanı hatası: {db_err}", exc_info=True)
        return jsonify({"error": "Veritabanı hatası oluştu."}), 500
    finally:
        conn.close()

    if not row or not row[0]:
        current_app.logger.warning(f"ZipPath verisi bulunamadı: IcerikId = {cid}")
        return jsonify({"error": "JPlag raporu (ZipPath) bulunamadı."}), 404

    zip_path = os.path.abspath(row[0])
    if not os.path.isfile(zip_path):
        current_app.logger.error(f"Zip dosyası diskte bulunamadı: {zip_path}")
        return jsonify({"error": f"Rapor zip dosyası bulunamadı: {zip_path}"}), 500

    jar_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "jplag-6.1.0-jar-with-dependencies.jar")
    if not os.path.isfile(jar_path):
        current_app.logger.error(f"JPlag JAR bulunamadı: {jar_path}")
        return jsonify({"error": "JPlag aracı (JAR dosyası) bulunamadı."}), 500

    port = 2999
    cmd = ["java", "-jar", jar_path, zip_path, "-M", "VIEW", "-l", lang, "-P", str(port)]
    current_app.logger.info(f"JPlag komutu çalıştırılıyor: {' '.join(cmd)}")

    try:
        proc = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            stdin=subprocess.PIPE,
            text=True,
            cwd=os.path.dirname(jar_path)
        )
    except FileNotFoundError:
        current_app.logger.error("Java bulunamadı. Java yüklü mü ve PATH'e eklendi mi?")
        return jsonify({"error": "Java bulunamadı. Lütfen Java'nın kurulu ve PATH'de olduğundan emin olun."}), 500
    except Exception as popen_e:
        current_app.logger.error(f"JPlag arayüzü başlatılamadı: {popen_e}", exc_info=True)
        return jsonify({"error": f"JPlag arayüzü başlatılamadı: {popen_e}"}), 500

    def _stream_jplag_log(process_to_log, log_prefix):
        def log_stream(stream, stream_name):
            try:
                for line in iter(stream.readline, ''):
                    current_app.logger.info(f"[{log_prefix}_{stream_name}] {line.strip()}")
            except Exception as e_stream:
                current_app.logger.error(f"Log akışında hata ({stream_name}): {e_stream}")
            finally:
                if stream and not stream.closed:
                    try:
                        stream.close()
                    except Exception as e_close:
                        current_app.logger.error(f"Akış kapatılamadı ({stream_name}): {e_close}")

        threading.Thread(target=log_stream, args=(proc.stdout, "STDOUT"), daemon=True).start()
        threading.Thread(target=log_stream, args=(proc.stderr, "STDERR"), daemon=True).start()

    _stream_jplag_log(proc, f"JPLAG_VIEW_{str(cid)[:8]}")
    time.sleep(2)

    if proc.poll() is not None:
        current_app.logger.error(f"JPlag işlemi erken sonlandı: IcerikId = {cid}")
        return jsonify({"error": "JPlag arayüzü başlatılırken bir sorun oluştu. Logları kontrol edin."}), 500

    VIEW_PROCS[str(cid)] = proc

    try:
        webbrowser.open(f"http://localhost:{port}")
    except Exception as wb_e:
        current_app.logger.warning(f"Tarayıcı açılamadı: {wb_e}")

    return jsonify({
        "message": "JPlag arayüzü başlatıldı.",
        "url": f"http://localhost:{port}"
    }), 200


@app.route('/compare_json', methods=['POST'])
def compare_json_route():
    data = request.get_json(force=True)
    required = ('KullaniciAdi1', 'KullaniciAdi2', 'Dosya1', 'Dosya2', 'BenzerlikOrani', 'ContentId', 'File1Id', 'File2Id')
    
    if not all(key in data for key in required):
        missing_keys = [key for key in required if key not in data]
        abort(400, f"Eksik anahtarlar: {', '.join(missing_keys)}")

    u1, u2 = data['KullaniciAdi1'], data['KullaniciAdi2']
    p1_orig, p2_orig = data['Dosya1'], data['Dosya2']
    
    content_id_str, file1_id_str, file2_id_str = data['ContentId'], data['File1Id'], data['File2Id']
    sim_str = data['BenzerlikOrani']
    
    try:
        sim = float(sim_str)
        content_id = int(content_id_str)
        file1_id = int(file1_id_str)
        file2_id = int(file2_id_str)
    except ValueError:
        abort(400, "'BenzerlikOrani' veya ID'ler sayısal bir değer olmalı.")

    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("""
        SELECT JsonFilePath FROM ComparisonJsonDetails
        WHERE ContentId = ? AND 
              ((FirstFileId = ? AND SecondFileId = ?) OR (FirstFileId = ? AND SecondFileId = ?))
        ORDER BY CreatedAt DESC
    """, (content_id, file1_id, file2_id, file2_id, file1_id))
    row = cursor.fetchone()
    conn.close()

    if row and row[0] and os.path.isfile(row[0]):
        try:
            with open(row[0], 'r', encoding='utf-8') as f:
                existing_json_data = json.load(f)
            current_app.logger.info(f"Returning pre-generated JSON for {file1_id}-{file2_id} from {row[0]}")
            return jsonify(existing_json_data), 200
        except Exception as e:
            current_app.logger.error(f"Error reading pre-generated JSON {row[0]}: {e}")
    
    current_app.logger.info(f"Pre-generated JSON not found or unreadable for {file1_id}-{file2_id}. Calculating on-the-fly.")

    if not os.path.isfile(p1_orig) or not os.path.isfile(p2_orig):
        missing = p1_orig if not os.path.isfile(p1_orig) else p2_orig
        abort(404, f"Dosya bulunamadı: {missing}")

    route_start_time = time.time()
    raw1 = read_text(p1_orig)
    raw2 = read_text(p2_orig)
    
    min_len_for_highlight = current_app.config.get('MIN_MATCH_LEN', 25)
    spans1, spans2 = get_difflib_spans(raw1, raw2, min_len=min_len_for_highlight)

    words1_list = raw1.split()
    words2_list = raw2.split()
    set1_words, set2_words = set(words1_list), set(words2_list)
    matching_words_set = set1_words & set2_words
    
    result_json_data = {
        "text1_html": raw1.replace('\n', '<br>'),
        "text2_html": raw2.replace('\n', '<br>'),
        "raw_text1": raw1,
        "raw_text2": raw2,
        "user1": u1,
        "user2": u2,
        "similarity": sim,
        "matchingWords": sorted(list(matching_words_set)),
        "totalWords1": len(words1_list),
        "totalWords2": len(words2_list),
        "matchingWordCount": len(matching_words_set),
        "uniqueWords1": len(set1_words - set2_words),
        "uniqueWords2": len(set2_words - set1_words),
        "matchSpans": [
            {"start1": s1, "length": l1, "start2": s2, "length": l2}
            for (s1, l1), (s2, l2) in zip(spans1, spans2)
        ],
        "diffSpans": [],
        "timeElapsed": round(time.time() - route_start_time, 4),
        "timestamp": datetime.datetime.now(timezone.utc).replace(microsecond=0).isoformat() + "Z",
        "content_id": content_id, 
        "file1_id": file1_id,     
        "file2_id": file2_id,     
        "file1_path_original": p1_orig,
        "file2_path_original": p2_orig,
        "source": "on-the-fly" 
    }
    return jsonify(result_json_data), 200

if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(name)s - %(message)s (%(pathname)s:%(lineno)d)')
    app.run(debug=True, host='0.0.0.0', port=5000)
